## File Management in Linux

Linux treats almost everything as a file (including devices, sockets, pipes). File management involves creating, viewing, copying, moving, deleting, linking, and inspecting files/directories.
Below are key commands and their use:

| Command                               | Purpose                                    | Common Options / Notes                                               |
| ------------------------------------- | ------------------------------------------ | -------------------------------------------------------------------- |
| `ls`                                  | List files/directories                     | `ls -l` shows detailed (permissions, owner, size, timestamps)        |
| `cd`                                  | Change current directory                   | `cd /path/to/dir`, `cd ..` (parent), `cd ~` (home)                   |
| `pwd`                                 | Print working directory                    | Shows the full path of your current directory                        |
| `mkdir`                               | Make (create) directory                    | Use `mkdir -p` to create intermediate parent directories             |
| `rmdir`                               | Remove empty directory                     | Only works if directory is empty                                     |
| `rm`                                  | Remove files or directories                | `-r` (recursive), `-f` (force), careful with deletion                |
| `cp`                                  | Copy files or directories                  | `cp source target`, `cp -r` for directories                          |
| `mv`                                  | Move or rename files/directories           | Also used to rename: `mv oldname newname`                            |
| `ln`                                  | Create hard or symbolic (soft) links       | `ln -s source linkname` for symlink                                  |
| `touch`                               | Create an empty file, or update timestamps | If file doesn’t exist, it’s created; if exists, timestamp is updated |
| `cat`, `less`, `more`, `head`, `tail` | View file contents                         | For example `cat file`, or use `less` for paging large files         |
| `chmod`                               | Change file/directory permissions (mode)   | Use symbolic (e.g. `u+x`) or numeric (e.g. `755`) modes              |
| `chown` / `chgrp`                     | Change file owner or group                 | `chown user:group file`                                              |
| `du`                                  | Disk usage                                 | e.g. `du -h` to show human-readable sizes of directories/files       |
| `df`                                  | Filesystem disk free space                 | Shows usage for mounted filesystems                                  |
| `find`                                | Find files/directories based on criteria   | e.g. `find / -name "*.log"`                                          |


## `chmod` — Change Mode (Permissions)
### Purpose
`chmod` changes the file mode bits (permissions) of files or directories. You can use **symbolic** or **octal (numeric)** notation to specify new permissions.
Only the file’s owner (or root) can change mode bits.
Basic usage: 
`chmod [OPTIONS] MODE FILE…`

**Modes: Symbolic vs Numeric:**
1- **Numeric (octal) notation**
Permissions are expressed in a 3-digit (or 4-digit) octal number:
- The first digit (hundreds place) is for **user** (owner)
- The second is for **group**
- The third is for **others**
- Optionally, a leading digit for special bits
Each digit is the sum of:
- `4` = read (r)
- `2` = write (w)
- `1` = execute (x)
Examples:
- `chmod 755 file` → owner: rwx (7), group: r-x (5), others: r-x (5)
- `chmod 644 file` → owner: rw- (6), group: r- (4), others: r- (4)
- `chmod 700 dir` → only the owner can read/write/execute; others nothing
Some special bits:
- **setuid** (4xxx)
- **setgid** (2xxx)
- **sticky bit** (1xxx) 


2- **Symbolic notation**
Syntax:
`[who][operator][permissions]`
- **who** can be any combination of:
    - `u` = user/owner
    - `g` = group
    - `o` = others
    - `a` = all (u + g + o)
- **operator**:
    - `+` : add permission
    - `-` : remove permission
    - `=` : set exactly (reset others)
- **permissions** are combinations of: `r`, `w`, `x`, `s` (setuid/setgid), `t` (sticky), `X` (special “execute” behavior)
    - `X` gives `execute` **only** if it’s a directory or if any execute bit is already set. Useful for recursive operations.
- You can chain multiple clauses separated by commas:
    `chmod u+r,g-w,o= file chmod a+rw file chmod u=rw,go=r file`
Examples:
- `chmod u+x file` — add execute to owner
- `chmod go-w file` — remove write from group and others
- `chmod a=r file` — set read-only for everyone
- `chmod u=rw,go=r file` — owner gets read/write; group and others get read only

Special Bits:
- **setuid (s / 4xxx)**: when an executable file with setuid is run, the process runs with the effective user ID of the file owner.
- **setgid (s / 2xxx)**: similar to setuid, but for group. Also, when set on a **directory**, new files created inside inherit its group.
- **sticky bit (t / 1xxx)**: on directories, only the file owner (or root) can remove or rename files inside, even if the directory is writable by others (common on `/tmp`).

You set these with symbolic or numeric means. For example:
- `chmod 4755 file` — sets setuid + rwxr-xr-x
- `chmod g+s dir` — setgid on a directory
- `chmod +t dir` — sticky bit on a directory

Examples: 
- Make a script executable by owner:
    `chmod u+x script.sh`
- Give read/write to owner, read-only to group and others:
    `chmod 644 file.txt`
- Recursively set permissions on a directory:
    `chmod -R 755 /var/www/html`
- Set sticky bit on a shared directory (so only owners can remove their files):
    `chmod +t /shared`
- Add execute permission for group without changing other bits:
    `chmod g+x file`




## `chown` — Change Owner (and Group)

### Purpose
`chown` changes the **user owner** and optionally the group of a file or directory. You can use it to transfer ownership among users.  
Because of the overlap in functionality, sometimes `chown` is used to change only the group (without changing the user) — effectively acting like `chgrp`.  
Only root (or users with appropriate privileges) can change the owner of a file; a normal user cannot change the owner to someone else. However, a user may change the group (via `chown`) under some circumstances (if allowed) depending on system policy.  
### Syntax & Options
Basic usage:
`chown [OPTIONS] [OWNER][:[GROUP]] FILE…`
- `OWNER` is the username or user ID
- `GROUP` is optional; if included after the colon, both owner and group change
- If you specify just `:GROUP`, it changes only the group (owner remains unchanged)  
- `-R`: recursive — affect entire directory tree
- `--reference=RFILE`: use the ownership from another file  
- `-v` verbose, `-c` changes only reported etc. depending on implementation

Examples:
- Change ownership to user `alice`:
    `sudo chown alice file.txt`
- Change both owner to `alice` and group to `developers`:
    `sudo chown alice:developers file.txt`
- Change only group (owner unchanged):
    `sudo chown :dev file.txt`
- Recursively change ownership of a directory tree:
    `sudo chown -R bob:staff /opt/myapp`
- Copy ownership from reference file:
    `sudo chown --reference=/path/to/ref file2`



## `chgrp` — Change Group Ownership

### Purpose
`chgrp` changes **only** the group of a file or directory. It is useful when you want to collaborate in a group without changing the file’s user owner.  
A file has a single group owner. Changing that group changes who (among group members) gets group-level permissions.  
By default, `chgrp` changes the group of the target (what a symbolic link points to). Some flags (`-h`) allow changing the group of the link itself rather than its target.  
### Syntax & Options
`chgrp [OPTIONS] GROUP FILE…`
- `GROUP` is the group name (or GID) you want to set
- `-R`: recursive (for directory and contents)
- `-h`: affects symbolic links themselves rather than targets
- `--reference=RFILE`: use group of reference file  

Examples:

- Change group to `staff`:
    `sudo chgrp staff project.txt`
- Change group recursively in a directory:
    `sudo chgrp -R devgroup /var/www/html`
- Use reference file:
    `sudo chgrp --reference=ref_file target_file`
- Change the group of a symlink itself (not its target):
    `sudo chgrp -h ggroup symlink`



## The `stat` Command in Linux

The `stat` utility (and the underlying `stat()` system call) provides detailed metadata about files, directories, or filesystems. It goes deeper than `ls -l` by giving information such as inode, blocks, timestamps, etc. 
### Syntax & Basic Usage
`stat [OPTION]... FILE...`
Some common options:
- `-L`, `--dereference`: follow symbolic links (i.e. show info about the target) 
- `-f`, `--file-system`: display file _system_ status instead of file status 
- `-c FORMAT`, `--format=FORMAT`: output in a custom format (like `printf`)
- `-t`, `--terse`: terse (condensed) form     
- `-Z`, `--context`: show SELinux security context (if applicable) 

Example:

`stat /etc/passwd`
Might output something like:
  `File: /etc/passwd   Size: 2779            Blocks: 8          IO Block: 4096   regular file Device: 10302h/66306d   Inode: 15616       Links: 1 Access: (0644/-rw-r--r--)  Uid: (    0/   root)   Gid: (    0/   root) Access: 2025-10-16 10:00:00.000000000 +0000 Modify: 2025-10-15 08:20:00.000000000 +0000 Change: 2025-10-15 08:20:00.000000000 +0000  Birth: -`

Here is what the fields mean:

|Field|Meaning|
|---|---|
|File|path to the file|
|Size|size in bytes|
|Blocks|number of 512-byte blocks allocated|
|IO Block|the filesystem block size for I/O|
|Device|device identifier (major/minor)|
|Inode|inode number (internal file index)|
|Links|number of hard links pointing to the file|
|Access (mode)|file permissions and type|
|Uid / Gid|user ID / group ID owning the file|
|Access / Modify / Change|timestamps: last access time (atime), last modification (mtime), last status change (ctime)|
|Birth|creation time (if supported by the filesystem)|

 Note: The “Birth” (creation) timestamp is not always available, depending on filesystem and kernel support.